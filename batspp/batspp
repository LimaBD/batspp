#!/usr/bin/env python3
#
# BATSPP
#
# Shell style tests using bats-core
#
## TODO: implement setup and teardown bats functions
## TODO: solve: tests can fail if they are saved with --output and dependency is not found
## TODO: implement -v and --version flags
## TODO: upgrade docstring
## TODO: add timer and print execution time
## TODO: set soft/hard interpretation with is_test_file to comment tests
## TODO: dont save file when no tests found
## TODO: implement tags e.g. <blank>
## TODO; add flag to print generated test (to follow bash pipes paradigm)
## TODO: re-instate the --source option
## TODO: use a separate pass of the test source to fill in the missing test names.


"""
BATSPP

Shell style tests using bats-core

You can run tests for aliases and more using the
command line with '$ [command]' followed by the
expected output:

 $ echo -e "hello\nworld"
 hello
 world

 $ echo "this is a test" | wc -c
 15

Also you can test bash functions:
 [functions + args] => [expected]:
 fibonacci 9 => "0 1 1 2 3 5 8 13 21 34"
"""


# Standard packages
import re


# Installed packages
from mezcla.main import Main
from mezcla import system
from mezcla import debug
from mezcla import glue_helpers as gh


# Local modules
from lexer import TextHandler, Lexer
from parser import Parser
from interpreter import Interpreter


# Command-line labels constants
FILE = 'file'
SAVE = 'save'
OUTPUT = 'output'


# Some constants
BATSPP_EXTENSION = 'batspp'
BATS_EXTENSION = 'bats'


class Batspp(Main):
    """Argument processing class"""

    # Class-level member variables for arguments
    # (avoids need for class constructor)
    file = ''
    save_path = ''
    output = False

    def setup(self):
        """Process arguments"""

        # Check the command-line options
        self.file = self.get_parsed_argument(FILE, self.file)
        self.save_path = self.get_parsed_argument(SAVE, self.save_path)
        self.output = self.has_parsed_option(OUTPUT)

        debug.trace(7, (f'batspp - file: {self.file}, '
                        f'save_path: {self.save_path}, '
                        f'output: {self.output}'))

    def run_main_step(self):
        """Process main script"""

        # Check file
        is_test_file = self.file.endswith(f'.{BATSPP_EXTENSION}')
        file_content = system.read_file(self.file)

        # Process file content
        text = TextHandler(file_content)
        tokens = Lexer().tokenize(text)
        abstract_syntax_tree = Parser().parse(tokens)
        bats_content = Interpreter().interpret(abstract_syntax_tree)

        # Set Bats output filename
        self.save_path = self.save_path if self.save_path else self.temp_file
        if self.save_path.endswith('/'):
            filename = re.search(r"\/(\w+)\.", self.file).group(0)
            self.save_path += f'{filename}.{BATS_EXTENSION}'

        if bats_content:
            gh.write_file(self.save_path, bats_content)
            gh.run(f'chmod +x {self.save_path}')
            debug.trace(7, f'batspp - running test {self.save_path}')

        ## TODO: check if some test command need sudo need sudo privileges
        root_privileges_needed = False

        # Print direct generated Bats file
        if self.output:
            print(bats_content)

        # Run generated Bats file
        elif bats_content:
            bats_command = f'bats {self.save_path}'
            if root_privileges_needed:
                print('Some founded test commands needs root privileges')
                bats_command = f'sudo {bats_command}'
            print(gh.run(bats_command))

        # Otherwise
        else:
            print(f'Not founded tests on file {self.file}')


if __name__ == '__main__':
    app = Batspp(description = __doc__,
                 positional_arguments = [(FILE, 'filename')],
                 boolean_options = [(OUTPUT, 'print output test')],
                 text_options = [(SAVE, 'specifies output path')],
                 manual_input = True)
    app.run()
