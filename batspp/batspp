#!/usr/bin/env python3
#
# BATSPP
#
# Shell style tests using bats-core
#
## TODO: implement -v and --version flags
## TODO: upgrade docstring
## TODO: add timer and print execution time
## TODO: set soft/hard interpretation with is_test_file to comment tests
## TODO: use a separate pass of the test source to fill in the missing test names.
## TODO: implement --discover flag to discover all tests file in a folder.


"""
BATSPP

Shell style tests using bats-core

You can run tests for aliases and more using the
command line with '$ [command]' followed by the
expected output:

 $ echo -e "hello\nworld"
 hello
 world

 $ echo "this is a test" | wc -c
 15

Also you can test bash functions:
 [functions + args] => [expected]:
 fibonacci 9 => "0 1 1 2 3 5 8 13 21 34"
"""


# Standard packages
import re
import os


# Installed packages
from mezcla.main import Main
from mezcla import system
from mezcla import debug
from mezcla import glue_helpers as gh


# Local modules
from lexer import Lexer
from parser import Parser
from interpreter import (
    Interpreter, TestOpts, TestArgs
)


# Command-line labels and
# enviroment variables constants
FILE = 'file'
SAVE = 'save'
SOURCES = 'sources'
OUTPUT = 'output'
VERBOSE_DEBUG = 'verbose_debug'
TMP = 'TMP'
TEMP_DIR = 'temp_dir'
COPY_DIR = 'copy_dir'
VISIBLE_PATH = 'visible_path'
RUN_OPTS = 'run_options'
SKIP_RUN = 'skip_run'
OMIT_TRACE = 'omit_trace'
DISABLE_ALIASES = 'disable_aliases'


# Some constants
BATSPP_EXTENSION = 'batspp'
BATS_EXTENSION = 'bats'


class Batspp(Main):
    """Argument processing class"""

    # Class-level member variables for arguments
    # (avoids need for class constructor)
    file = ''
    save_path = ''
    sources = []
    output = False
    verbose_debug = False
    temp_dir = ''
    copy_dir = ''
    visible_paths = ''
    run_opts = ''
    skip_run = False
    omit_trace = False
    disable_aliases = False

    def setup(self) -> None:
        """Process arguments"""
        debug.trace(7, f'batspp.setup() self={self}')

        tmp = system.getenv_text(TMP, "/tmp", "Temporary directory")

        # Check the command-line/enviroment vars options
        self.file = self.get_parsed_argument(FILE, self.file)
        self.save_path = self.get_entered_text(SAVE, self.temp_file)
        self.sources = self.get_entered_text(SOURCES, '').split(' ' or ',' or ';')
        self.output = self.get_entered_bool(OUTPUT, self.output)
        self.verbose_debug = self.get_entered_bool(VERBOSE_DEBUG, self.verbose_debug)
        self.temp_dir = self.get_entered_text(TEMP_DIR, gh.form_path(tmp, f"batspp-{os.getpid()}"))
        self.copy_dir = self.get_entered_text(COPY_DIR, self.copy_dir)
        self.visible_paths = self.get_entered_text(VISIBLE_PATH, self.visible_paths).split(' ' or ',' or ';')
        self.run_opts = self.get_entered_text(RUN_OPTS, self.run_opts)
        self.skip_run = self.get_entered_bool(SKIP_RUN, self.skip_run)
        self.omit_trace = self.get_entered_bool(OMIT_TRACE,  self.omit_trace)
        self.disable_aliases = self.get_entered_bool(DISABLE_ALIASES,  self.disable_aliases)

    def run_main_step(self) -> None:
        """Process main script"""

        tests = Test()

        opts = TestOpts(embedded_tests = not self.file.endswith(f'.{BATSPP_EXTENSION}'),
                        verbose_debug = self.verbose_debug,
                        omit_trace = self.omit_trace,
                        disable_aliases = self.disable_aliases)

        args = TestArgs(sources = self.sources,
                        temp_dir = self.temp_dir,
                        visible_paths = self.visible_paths,
                        run_opts = self.run_opts,
                        copy_dir = self.copy_dir)

        try:
            tests.build(system.read_file(self.file),
                        opts = opts,
                        args = args)
        except: # pylint: disable=bare-except
            print(f'Not founded tests on file {self.file}')
            return

        # Build a filename to save the tests
        # if the entered path only contains a dir path
        if self.save_path.endswith('/'):
            filename = re.search(r"\/(\w+)\.", self.file).group(0)
            self.save_path += f'generated_{filename}.{BATS_EXTENSION}'

        tests.save(self.save_path)

        # STDOUT
        if self.output:
            print(tests.get_tests())
        elif not self.skip_run:
            print(tests.run(self.run_opts))

    def get_entered_bool(self, label:str, default:bool=False) -> bool:
        """
        Return entered LABEL var/arg bool by command-line or enviroment variable,
        also can be specified a DEFAULT value
        """
        debug.trace(7, f'batspp.get_entered_bool(label={label})')
        return (self.has_parsed_option(label.lower()) or
                system.getenv_bool(var=label.upper(), default=default))

    def get_entered_text(self, label:str, default:str='') -> str:
        """
        Return entered LABEL var/arg text by command-line or enviroment variable,
        also can be specified a DEFAULT value
        """
        debug.trace(7, f'batspp.get_entered_text(label={label})')
        return (self.get_parsed_argument(label=label.lower(), default=default) or
                system.getenv_text(var=label.upper(), default=default))


class Test:
    """
    This is responsible to build and run test
    """

    def __init__(self) -> None:

        # Global states
        self.content = ''
        self.path = ''

    def build(self,
              text: str,
              opts: TestOpts = TestOpts(),
              args: TestArgs = TestArgs()) -> None:
        """
        Build tests from TEXT,
        with OPTS can be setted test options and with
        ARGS can be setted test arguments
        """

        # Process tests
        tokens = Lexer().tokenize(text, opts.embedded_tests)
        tree = Parser().parse(tokens)
        self.content = Interpreter().interpret(tree, opts=opts, args=args)

        assert self.content, 'No tests founded'

    def get_tests(self) -> str:
        """Return tests"""
        debug.trace(7, 'Test.get_tests()')
        return self.content

    def save(self, path: str) -> None:
        """Save tests on PATH"""
        debug.trace(7, f'Test.save({path})')

        assert path, 'PATH string cannot be empty'
        assert self.content, 'Tests must be builded, try build() method'

        self.path = path

        gh.write_file(path, self.content)
        gh.run(f'chmod +x {path}')

    def run(self, opts:str='') -> str:
        """
        Return stdout from runned tests
        with OPTS (options) can be used aditional options to run
        """
        debug.trace(7, f'Test.run() on path={self.path}')

        assert self.path, 'Tests must be saved, try save() method'

        # Check for root permissions
        sudo = 'sudo' if 'sudo' in self.content else ''

        return gh.run(f'{sudo} bats {opts} {self.path}')


if __name__ == '__main__':
    app = Batspp(description = __doc__,
                 positional_arguments = [(FILE, 'Test filename')],
                 boolean_options = [(OUTPUT, 'Print generated test'),
                                    (VERBOSE_DEBUG, 'Print debug verbose when an assertion fail'),
                                    (SKIP_RUN, 'Do not run the test script'),
                                    (OMIT_TRACE, 'Omit actual/expected trace from test file'),
                                    (DISABLE_ALIASES, 'Disable alias expansion')],
                 text_options = [(SAVE, 'Specify path to save the generated test file'),
                                 (SOURCES, 'Specify files to be sourced, i.e "file1.bash file2.bash"'),
                                 (TEMP_DIR, 'Temporary directory to use for tests'),
                                 (VISIBLE_PATH, 'Make paths visible to tests file'),
                                 (RUN_OPTS, 'Options for run Bats command'),
                                 (COPY_DIR, 'Copy directory to temp. dir for input files, etc.')],
                 manual_input = True)
    app.run()
