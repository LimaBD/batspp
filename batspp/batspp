#!/usr/bin/env python3
#
# BATSPP
#
# Shell style tests using bats-core
#
## TODO: implement setup and teardown bats functions
## TODO: solve: tests can fail if they are saved with --output and dependency is not found
## TODO: implement -v and --version flags
## TODO: upgrade docstring
## TODO: add timer and print execution time
## TODO: set soft/hard interpretation with is_test_file to comment tests
## TODO: use a separate pass of the test source to fill in the missing test names.
## TODO: implement --discover flag to discover all tests file in a folder.


"""
BATSPP

Shell style tests using bats-core

You can run tests for aliases and more using the
command line with '$ [command]' followed by the
expected output:

 $ echo -e "hello\nworld"
 hello
 world

 $ echo "this is a test" | wc -c
 15

Also you can test bash functions:
 [functions + args] => [expected]:
 fibonacci 9 => "0 1 1 2 3 5 8 13 21 34"
"""


# Standard packages
import re


# Installed packages
from mezcla.main import Main
from mezcla import system
from mezcla import debug
from mezcla import glue_helpers as gh


# Local modules
from lexer import Lexer
from parser import Parser
from interpreter import Interpreter, TestData


# Command-line labels constants
FILE = 'file'
SAVE = 'save'
SOURCE = 'source'
OUTPUT = 'output'
VERBOSE_DEBUG = 'verbose_debug'


# Some constants
BATSPP_EXTENSION = 'batspp'
BATS_EXTENSION = 'bats'


class Batspp(Main):
    """Argument processing class"""

    # Class-level member variables for arguments
    # (avoids need for class constructor)
    file = ''
    save_path = ''
    source = ''
    output = False
    verbose_debug = False

    def setup(self):
        """Process arguments"""

        # Check the command-line options
        self.file = self.get_parsed_argument(FILE, self.file)
        self.save_path = self.get_parsed_argument(SAVE, self.temp_file)
        self.source = self.get_parsed_argument(SOURCE, self.source)
        self.output = self.has_parsed_option(OUTPUT)
        self.verbose_debug = self.has_parsed_option(VERBOSE_DEBUG)

        debug.trace(7, (f'batspp.setup({self}) - \n'
                        f'\t{FILE}: {self.file},\n'
                        f'\t{SAVE}: {self.save_path},\n'
                        f'\t{SOURCE}: {self.source},\n'
                        f'\t{OUTPUT}: {self.output},\n'
                        f'\t{VERBOSE_DEBUG}: {self.verbose_debug}'))

    def run_main_step(self):
        """Process main script"""

        tests = Test()
        data = TestData(source = self.source,
                        embedded_tests = not self.file.endswith(f'.{BATSPP_EXTENSION}'),
                        verbose_debug = self.verbose_debug)

        try:
            tests.build(system.read_file(self.file), data=data)
        except: # pylint: disable=bare-except
            print(f'Not founded tests on file {self.file}')
            return

        # Build a filename to save the tests
        # if the entered path only contains a dir path
        if self.save_path.endswith('/'):
            filename = re.search(r"\/(\w+)\.", self.file).group(0)
            self.save_path += f'generated_{filename}.{BATS_EXTENSION}'

        tests.save(self.save_path)

        # STDOUT
        if self.output:
            print(tests.get_tests())
        else:
            print(tests.run())


class Test:
    """
    This is responsible to build and run test
    """

    def __init__(self) -> None:

        # Global states
        self.root_required = False
        self.content = ''
        self.path = ''

    def build(self,
              text: str,
              data: TestData = None) -> None:
        """
        Build tests from TEXT,
        scripts files can be sourced with SOURCE,
        with DEBUG_HEXVIEW, hexview of actual and expeted
        values on assertions are printed
        """

        # Process tests
        tokens = Lexer().tokenize(text, data.embedded_tests)
        tree = Parser().parse(tokens)
        self.content = Interpreter().interpret(tree, data)

        assert self.content, 'No tests founded'

        self.root_required = 'sudo' in self.content

    def get_tests(self) -> str:
        """Return tests"""
        debug.trace(7, 'Test.get_tests()')
        return self.content

    def save(self, path: str) -> None:
        """Save tests on PATH"""
        debug.trace(7, f'Test.save({path})')

        assert path, 'PATH string cannot be empty'
        assert self.content, 'Tests must be builded, try build() method'

        self.path = path

        gh.write_file(path, self.content)
        gh.run(f'chmod +x {path}')

    def run(self) -> str:
        """Return stdout from runned tests"""
        debug.trace(7, f'Test.run() on path={self.path}')

        assert self.path, 'Tests must be saved, try save() method'

        sudo = 'sudo' if self.root_required else ''

        return gh.run(f'{sudo} bats {self.path}')


if __name__ == '__main__':
    app = Batspp(description = __doc__,
                 positional_arguments = [(FILE, 'filename')],
                 boolean_options = [(OUTPUT, 'print output test'),
                                    (VERBOSE_DEBUG, 'print debug verbose when an assertion fail')],
                 text_options = [(SAVE, 'specifies path to save the generated bats file'),
                                 (SOURCE, 'specifies file to be sourced')],
                 manual_input = True)
    app.run()
